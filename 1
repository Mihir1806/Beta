def parent_child(self):
    import pandas as pd

    # ğŸ” Step 1: Build Code â†’ Level mapping from self.SubProduct
    code_to_level = {}
    for _, row in self.SubProduct.iterrows():
        code = str(row['Code']).strip() if pd.notna(row['Code']) else None
        if not code:
            continue  # Skip if no code
        for i in range(1, 7):
            niv_col = f'Niv {i}'
            if niv_col in row and pd.notna(row[niv_col]):
                code_to_level[code] = i  # Assign the first level where code has a description
                break

    # ğŸ§  Step 2: Function to check if SubProductIAS is child of Type of operation
    def is_child(row):
        code1 = str(row['SubProductIAS']).strip()
        code2 = str(row['Type of operation']).strip()
        level1 = code_to_level.get(code1)
        level2 = code_to_level.get(code2)
        if level1 is not None and level2 is not None:
            return level1 > level2  # child if level1 > level2
        return False  # If level info is missing, treat as no relation

    # ğŸª„ Step 3: Apply the check and tag each row
    self.result3 = self.result3.assign(parent_match=self.result3.apply(is_child, axis=1))

    # ğŸ“¤ Step 4: Split into result3A (child-of match) and result3B (others)
    self.result3A = self.result3[self.result3['parent_match']].drop(columns=['parent_match'])
    self.result3B = self.result3[~self.result3['parent_match']].drop(columns=['parent_match'])

    print("âœ… Parent-child classification done: result3A (matched) and result3B (unmatched) created.")