def parent_child(self):
    import pandas as pd

    # ✅ Step 1: Build code → (level, row) mapping
    code_to_level = {}
    code_to_row = {}
    
    for _, row in self.SubProduct.iterrows():
        code = str(row['Code']).strip()
        for i in range(1, 7):
            niv_col = f'Niv {i}'
            if pd.notna(row[niv_col]):
                code_to_level[code] = i
                code_to_row[code] = row
                break  # One Niv per code guaranteed

    # ✅ Step 2: Define function to walk up and check if parent exists
    def is_descendant(row):
        child_code = str(row['SubProductIAS']).strip()
        parent_code = str(row['Type of operation']).strip()

        if child_code not in code_to_level or parent_code not in code_to_level:
            return False

        child_level = code_to_level[child_code]
        parent_level = code_to_level[parent_code]

        if parent_level >= child_level:
            return False  # A parent must be at a higher level (lower number)

        # Get the full row of the child to trace hierarchy up
        child_row = code_to_row[child_code]

        # Check all higher-level Niv columns in the child row for parent's description
        for i in range(1, child_level):
            niv_col = f'Niv {i}'
            parent_description = self.SubProduct.loc[
                self.SubProduct['Code'] == parent_code, f'Niv {i}'
            ].values

            if len(parent_description) == 0 or pd.isna(child_row[niv_col]):
                continue

            if str(child_row[niv_col]).strip() == str(parent_description[0]).strip():
                return True

        return False

    # ✅ Step 3: Apply function and split result
    matches = self.result3.apply(is_descendant, axis=1)
    self.result3A = self.result3[matches].reset_index(drop=True)
    self.result3B = self.result3[~matches].reset_index(drop=True)

    print("Classified into result3A (valid parent) and result3B (not related).")