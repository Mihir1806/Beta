def parent_child(self):
    import pandas as pd

    # ✅ Step 1: Build mapping - Code → Niv Level and row-wise hierarchy
    code_to_level = {}
    code_to_parents = {}

    for _, row in self.SubProduct.iterrows():
        row = row.dropna()
        niv_columns = [col for col in row.index if col.startswith('Niv ')]
        code = str(row['Code']).strip()

        # Find which Niv the code belongs to
        for i in range(1, 7):
            niv_col = f'Niv {i}'
            if pd.notna(row.get(niv_col)) and row.get(niv_col) != '':
                code_to_level[code] = i
                # Store all previous Niv codes in same row as ancestors
                parents = []
                for j in range(1, i):
                    parent_code = row.get(f'Niv {j}')
                    if pd.notna(parent_code) and parent_code != '':
                        parents.append(str(parent_code).strip())
                code_to_parents[code] = parents
                break

    # ✅ Step 2: Check if SubProductIAS is descendant of Type of operation
    def is_child_of(row):
        try:
            child_code = str(row['SubProductIAS']).strip()
            parent_code = str(row['Type of operation']).strip()
            return parent_code in code_to_parents.get(child_code, [])
        except Exception:
            return False

    # ✅ Step 3: Apply function
    self.result3['parent_match'] = self.result3.apply(is_child_of, axis=1)

    # ✅ Step 4: Split into result3A (match) and result3B (no match)
    self.result3A = self.result3[self.result3['parent_match']].drop(columns=['parent_match'])
    self.result3B = self.result3[~self.result3['parent_match']].drop(columns=['parent_match'])

    print("✅ parent_child(): Split result3 into result3A (child of) and result3B (not child of)")