def parent_child(self):
    import pandas as pd

    # Step 1: Map each code to its Niv level and parent
    code_to_level = {}
    hierarchy = {}

    for _, row in self.SubProduct.iterrows():
        code = str(row['Code']).strip() if pd.notna(row['Code']) else None
        if not code:
            continue
        for i in range(1, 7):
            niv_col = f'Niv {i}'
            if pd.notna(row[niv_col]):
                level = i
                code_to_level[code] = level
                if level > 1:
                    parent_col = f'Niv {level - 1}'
                    parent_code = str(row[parent_col]).strip() if pd.notna(row[parent_col]) else None
                    if parent_code:
                        hierarchy[code] = parent_code
                break

    # Step 2: Check ancestry
    def has_parent(child_code, potential_parent):
        current = child_code
        visited = set()
        while current in hierarchy:
            current = hierarchy[current]
            if current == potential_parent:
                return True
            if current in visited:
                break
            visited.add(current)
        return False

    # Step 3: Apply ancestry check
    def check_ancestry(row):
        child = str(row['SubProductIAS']).strip()
        parent = str(row['Type of operation']).strip()
        return has_parent(child, parent)

    self.result3['parent_match'] = self.result3.apply(check_ancestry, axis=1)
    self.result3A = self.result3[self.result3['parent_match']].drop(columns=['parent_match'])
    self.result3B = self.result3[~self.result3['parent_match']].drop(columns=['parent_match'])

    print("parent_child(): result3 split into result3A (child of) and result3B (not child of)")